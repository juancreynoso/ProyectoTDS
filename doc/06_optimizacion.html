<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Optimización</title>
  <link rel="stylesheet" href="css/style.css">
</head>
<body>
  <header>
    <h1>Optimización</h1>
    <nav>
      <ul>
        <li><a href="index.html">Inicio</a></li>
        <li><a href="01_analisis_lexico.html">Análisis Léxico</a></li>
        <li><a href="02_analisis_sintactico.html">Análisis Sintáctico</a></li>
        <li><a href="03_analisis_semantico.html">Análisis Semántico</a></li>
        <li><a href="04_codigo_intermedio.html">Generación de Código Intermedio</a></li>
        <li><a href="05_codigo_objeto.html">Generación de Código Assembler</a></li>
        <li><a href="06_optimizacion.html">Optimización</a></li>
      </ul>
    </nav>
  </header>

  <main>
    <h2>Descripción</h2> 
    <p>En esta etapa se aplicaron una serie de optimizaciones en distintas etapas para producir un codigo de mejor calidad y mas eficiente.</p>

    <h2>Optimizaciones generadas</h2>
    <h3>Propagación de constantes</h3>
    <p>
      Esta optimización consiste en reemplazar expresiones compuestas por constantes, por el valor que denotan. De esta manera, expresiones como <code>x = 5 * 5</code> 
      se simplifican directamente a <code>x = 25</code>, reduciendo la carga de cálculos en tiempo de ejecución. Además, al propagarse estas constantes a lo largo del 
      árbol sintáctico abstracto (AST), este ultimo puede simplificarse y por ende resultara un codigo mas liviano y simple.
    </p>

    <h4>Por ejemplo, teniendo el siguiente programa:</h4>

    <pre>
    Program
    {
      integer main() {
          integer x = 10 + 7 + 1 + ((10 * 10)/ 10);
          return x;
      }
    }
    </pre>
            
    <h4>Sin aplicar la optimización:</h4>

    <pre>
      Program
        decl
            int main() size: 0 
                block 
                  decl
                    =
                        int x
                        +
                          +
                              +
                                10
                                7
                              1
                          /
                              *
                                10
                                10
                              10
                  stmt
                    ret 
                        x
    </pre>

    <h4>Aplicando la optimización:</h4>

    <pre>
      Program
        decl
            int main() size: 0 
                block 
                  decl
                    =
                        int x
                        28
                  stmt
                    ret 
                        x        
    </pre>

    <h3>Codigo muerto</h3>
    <p>
      Esta optimización consiste en <b>NO</b> generar codigo para aquellas sentencias que siguen a una sentencia <b>return</b>, ya que no seran ejecutadas. Esto resulta en un 
      codigo mas simple y un poco mas eficiente.
    </p>

    <h4>Por ejemplo, teniendo el siguiente programa:</h4>

    <pre>
    Program
    {
        integer main() {
            integer x = 10 + 9;
            return x;
            x = 10;
            if (x < 10) then {
                x = 10;
            } else {
                x = 20;
            }
            return x;
        }
    }
    </pre>

    <h4>Sin aplicar la optimización:</h4>

    <pre>
    Program
      decl
          int main() 
              block 
                decl
                  =
                      int x
                      +
                        10
                        9
                stmt
                  ret 
                      x
                  stmt
                      =
                        x
                        10
                      stmt
                        if 
                            <
                              x
                              10
                            block 
                              stmt
                                  =
                                    x
                                    10
                            block 
                              stmt
                                  =
                                    x
                                    20
                        stmt
                            ret 
                           x
    </pre>

    <h4>Aplicando la optimización:</h4>

    <pre>
    Program
      decl
          int main() 
              block 
                decl
                  =
                      int x
                      19
                stmt
                  ret 
                      x
    </pre>

    <p>
      <b>Nota:</b> es importante destacar que, por una decisión de diseño, la optimización de código muerto se aplica únicamente dentro de un mismo bloque. 
      Es decir, no se considera cómo pueden afectar sentencias <code>return</code> dentro de un bloque, al código siguiente al mismo. Para realizar un análisis más detallado,
      sería necesario contar con una estructura más compleja, como un grafo de control de flujo.
    </p>

    <h3>División por constante "2"</h3>

    <p>
      Esta optimización se basa en que, cuando tenemos una division por la constante entera <b>2</b>, se utiliza la instruccion de <b>shift</b>, en lugar de usar la instruccion <b>idiv</b> por ejemplo. Basicamente hay un cambio
      en el codigo assembler que se genera. Hacer este cambio resulta en un codigo mas eficiente y simple.
    </p>

    <h4>Por ejemplo, teniendo el siguiente programa:</h4>
    <pre>
    Program
    {
        void main() {
            integer x = 10/2;
        }
    }

    </pre>

    <h4>Sin aplicar la optimización:</h4>

    <pre>
    .data

    .text
    .globl main
    main: 
        enter  $16, $0
        mov $10, %r10
        mov %r10, -8(%rbp)
        mov -8(%rbp), %rax
        xor %rdx, %rdx
        cqto
        mov $2, %r10
        idiv %r10
        mov %rax, -16(%rbp)
        mov -16(%rbp), %r10
        mov %r10, -8(%rbp)
    .L0:
        leave
        ret
      
    </pre>
    
    <h4>Aplicando la optimización:</h4>

    <pre>
    .data

    .text
    .globl main
    main: 
        enter  $16, $0
        mov $10, %rax
        xor %rdx, %rdx
        cqto
        sar $1, %rax
        mov %rax, -8(%rbp)
        mov -8(%rbp), %r10
        mov %r10, -16(%rbp)
    .L0:
        leave
        ret
      
    </pre>    

    <h3>Reasignación de offsets</h3>
    <p>
      Además de las optimizaciones anteriores, se implementó una optimización de <b>memoria</b>. 
      En lugar de asignar un nuevo offset cada vez que se crea un temporal (decrementando 8 bytes continuamente), 
      el compilador detecta cuándo un temporal ya no se utiliza y guarda su offset en una lista de offsets libres.
      Luego, al necesitar asignar un nuevo temporal, se reutiliza el primer offset disponible. 
      Si no hay offsets libres, se continúa con la asignación normal.
    </p>

    <h4>Por ejemplo, teniendo el siguiente programa:</h4>
    <pre>
    Program {
        integer print(integer a) extern;

        integer main() {
            integer y = 1;
            integer x = 0;
            x = y + 3;
            y = x * 2;

            print(y);
            return y;
        }
    }
    </pre>

    <h4>Sin aplicar la optimización:</h4>

    <pre>
    .data

    .text
    .globl main
    main: 
        enter  $40, $0
        mov $1, %r10
        mov %r10, -8(%rbp)
        mov $0, %r10
        mov %r10, -16(%rbp)
        mov -8(%rbp), %r10
        add $3, %r10
        mov %r10, -24(%rbp)
        mov -24(%rbp), %r10
        mov %r10, -16(%rbp)
        mov -16(%rbp), %r10
        imul $2, %r10
        mov %r10, -32(%rbp)
        mov -32(%rbp), %r10
        mov %r10, -8(%rbp)
        mov -8(%rbp), %rdi
        call print
        mov %rax, -40(%rbp)
        mov -8(%rbp), %rax
    .L0:
        leave
        ret
    </pre>

    <h4>Aplicando optimización:</h4>
    <pre>
      .data

    .text
    .globl main
    main: 
        enter  $24, $0
        mov $1, %r10
        mov %r10, -8(%rbp)
        mov $0, %r10
        mov %r10, -16(%rbp)
        mov -8(%rbp), %r10
        add $3, %r10
        mov %r10, -24(%rbp)
        mov -24(%rbp), %r10
        mov %r10, -16(%rbp)
        mov -16(%rbp), %r10
        imul $2, %r10
        mov %r10, -24(%rbp)
        mov -24(%rbp), %r10
        mov %r10, -8(%rbp)
        mov -8(%rbp), %rdi
        call print
        mov %rax, -24(%rbp)
        mov -8(%rbp), %rax
    .L0:
        leave
        ret
    </pre>
    <p>
      Observando los ejemplos anteriores, se aprecia cómo los offsets se reutilizan para distintos temporales 
      y cómo la instrucción <code>enter</code> reserva un espacio de pila menor, evidenciando un uso de memoria más eficiente.
    </p>
    <h2>División de trabajo</h2>
      <p>
        Se implementaron cuatro optimizaciones en total. Cada integrante del equipo desarrolló dos de ellas:  
        por un lado, la <b>eliminación de código muerto</b> y la <b>división por constante 2</b>;  
        por el otro, la <b>propagación de constantes</b> y la <b>reutilización de offsets</b>.
      </p>

  </main>

  <footer>
    <a href="index.html">← Volver al índice</a>
  </footer>
</body>
</html>
