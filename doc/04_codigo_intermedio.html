<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Análisis Semantico</title>
  <link rel="stylesheet" href="css/style.css">
</head>
<body>
  <header>
    <h1>Generación de Código Intermedio</h1>
    <nav>
      <ul>
        <li><a href="index.html">Inicio</a></li>
        <li><a href="01_analisis_lexico.html">Análisis Léxico</a></li>
        <li><a href="02_analisis_sintactico.html">Análisis Sintáctico</a></li>
        <li><a href="03_analisis_semantico.html">Análisis Semántico</a></li>
        <li><a href="04_codigo_intermedio.html">Generación de Código Intermedio</a></li>
        <li><a href="05_codigo_objeto.html">Generación de Código Objeto</a></li>
        <li><a href="06_optimizacion.html">Optimización</a></li>
      </ul>
    </nav>
  </header>
  <main>
    <h2>Descripción</h2>

    <p>
        La etapa de <b>Generación de Código Intermedio</b> tiene como objetivo llevar la 
        representación del programa en el <b>Árbol de Sintaxis Abstracta (AST)</b> hacia una 
        forma más cercana al código máquina, pero aún independiente de la arquitectura: el 
        <b>Código de Tres Direcciones (TAC)</b>. 
    </p>

    <p>
        Este formato intermedio permite expresar operaciones complejas en una secuencia de 
        instrucciones simples, generalmente con la forma:
        <pre><code>resultado := operando1 operador operando2</code></pre>
        Cada instrucción se asemeja a una operación en ensamblador, pero mantiene la 
        claridad y estructura necesarias para análisis y optimización posteriores.
    </p>

    <h2>Estructuras Implementadas</h2>

    <p>
        Para la generación del código intermedio se definieron las siguientes estructuras principales:
    </p>

    <ul>
        <li>
        <b><code>operand</code></b>: representa una entidad sobre la que puede operar una instrucción 
        (constantes, variables, temporales, etc.). Cada operando mantiene una referencia 
        al nodo correspondiente del AST a través de su campo <code>info</code>.
        </li>
        <li>
        <b><code>instruction</code></b>: representa una instrucción de tres direcciones. 
        Contiene el tipo de instrucción (por ejemplo, <code>PLUS</code>, <code>ASSIGN</code>, <code>RET</code>), 
        y tres operandos: <code>op1</code>, <code>op2</code> y <code>result</code>.
        </li>
        <li>
        <b><code>instruction_list</code></b>: lista enlazada de instrucciones, que permite almacenar 
        de forma secuencial el código generado durante el recorrido del AST.
        </li>
    </ul>

    <h2>Recorrido del AST y Generación del TAC</h2>

    <p>
        La generación del código intermedio se realiza mediante un recorrido recursivo del 
        árbol de sintaxis abstracta. Durante este recorrido, cada tipo de nodo produce una 
        o varias instrucciones TAC:
    </p>

    <ul>
        <li><b>Expresiones aritméticas</b>: generan instrucciones como 
        <code>t1 := a + b</code> o <code>t2 := t1 * 2</code>, 
        utilizando variables temporales para almacenar resultados intermedios.
        </li>
        <li><b>Asignaciones</b>: traducidas a la forma 
        <code>x := t1</code>, donde el resultado de una expresión se guarda en la variable de destino.
        </li>
        <li><b>Sentencias de retorno</b>: producen una instrucción del tipo 
        <code>RET t1</code>, que indica el valor a devolver por una función.
        </li>
        <li><b>Declaraciones y llamadas de métodos</b>: generan instrucciones 
        <code>FUNC nombre</code>, <code>CALL nombre</code> y <code>FFUNC</code>, 
        para marcar el inicio, invocación y fin de una función respectivamente.
        </li>
        <li><b>Control de flujo (if / while)</b>: utilizan etiquetas (<code>LABEL</code>) 
        y saltos condicionales (<code>IF_FALSE_GOTO</code>, <code>GOTO</code>) 
        para modelar la lógica de bifurcación o repetición.
        </li>
    </ul>

    <p>
        Las variables temporales y etiquetas se generan automáticamente con funciones auxiliares 
        (<code>new_temp()</code> y <code>new_label()</code>), que garantizan nombres únicos 
        para cada operación.
    </p>

    <h2>Ejemplo de Código Intermedio</h2>

    <p>
        Para el siguiente fragmento de código fuente:
    </p>

    <pre><code>
        Program {
            integer main() {
                integer a = 1 + 2;
                return a;
            }
        }
    </code></pre>

    <p>El código intermedio generado es:</p>

    <pre><code>
        PROGRAM
        FUNC main
        t0 := 1 PLUS 2
        a := t0
        RET a
        FFUNC
        END
    </code></pre>

    <h2>Consideraciones</h2>

    <p>
        Si bien la salida en formato TAC se utiliza principalmente con fines de depuración 
        y visualización, la información completa del programa (parámetros, tipos, valores y 
        contexto) permanece almacenada en los nodos del AST referenciados por cada instrucción.
        Esto permite que la siguiente etapa —<b>Generación de Código Objeto</b>— 
        acceda a todos los detalles semánticos necesarios sin necesidad de extender el formato textual del TAC.
    </p>
    </main>

    <footer>
    <a href="index.html">← Volver al índice</a>
    </footer>
</body>
</html>     