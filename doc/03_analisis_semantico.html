<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Análisis Semantico</title>
  <link rel="stylesheet" href="css/style.css">
</head>
<body>
  <header>
    <h1>Análisis Semántico</h1>
    <nav>
      <ul>
        <li><a href="index.html">Inicio</a></li>
        <li><a href="01_analisis_lexico.html">Análisis Léxico</a></li>
        <li><a href="02_analisis_sintactico.html">Análisis Sintáctico</a></li>
        <li><a href="03_analisis_semantico.html">Análisis Semántico</a></li>
        <li><a href="04_codigo_intermedio.html">Generación de Código Intermedio</a></li>
        <li><a href="05_codigo_objeto.html">Generación de Código Objeto</a></li>
        <li><a href="06_optimizacion.html">Optimización</a></li>
      </ul>
    </nav>
  </header>
  <main>
    <h2>Descripción</h2>
    <p>
    El <b>análisis semántico</b> tiene objetivo principal verificar la validez lógica de un programa,
    comprobando que las variables y métodos estén correctamente <i>declarados</i>, y que los <i>tipos de datos sean compatibles</i>.
    Es por ello que, es necesario apoyarse en dos estructuras fundamentales: 
    el <b>Árbol de Sintaxis Abstracta (AST)</b>, que representa la jerarquía y relaciones sintácticas del programa, 
    y la <b>Tabla de Símbolos (ST)</b>, que organiza y almacena información sobre los identificadores y sus ámbitos. 
    La interacción entre estas dos estructuras permite realizar chequeos semánticos de manera precisa y consistente durante el recorrido del AST.
    </p>

    <h2>Generacion del AST</h2>

    <p>El <b>AST</b> se genera a partir de la gramática definida en el archivo <i>sintax.y</i> de bison. Se define la estructura del ast y las funcionalidades a partir de los
    archivos <i>ast.h</i> y <i>ast.c</i>.
    Para la comunicación entre el analizador léxico (Flex) y el analizador sintáctico (Bison), se utiliza la variable global <b><i>yylval</i></b>. 
    Esta variable permite transferir el valor semántico asociado a cada token. Por ejemplo, cuando el analizador léxico reconoce una cadena que 
    representa un número entero, retorna el token correspondiente y, mediante yylval, también pasa el valor numérico. De esta manera,
    el analizador sintáctico puede utilizar esa información en las acciones semánticas para construir los nodos del AST.
    <h3>Un ejemplo de construccion de un nodo</h3>
    <p>En el analizador lexico:</p>
    <pre>
    ...

    {digit}+{   
              printf("NUM \n"); 
              yylval.ival = atoi(yytext);
              return NUM;
            }  
    
    ...
    </pre>

    <p>En el analizador sintactico:</p>
    <pre>
    ...

    expr: ID { $$ = create_id_node($1, NONE, NODE_ID_USE); }
        | NUM { $$ = create_int_node($1); }
    
    ...
    </pre>
    <p>
      Es importante destacar que para que esto funcione correctamente ademas se debe definir un tipo de dato <i>union</i> que, 
      permite pasar distintos tipos de valores del analizador lexico al analizador sintacto (a traves de yylval), asi como 
      tambien permite determinar a que tipos de datos estan asociados los simbolos terminales y no terminales de la gramatica el
      cual nos favorece para armar el ast. Esto nos permite hacer uso de la notacion <i>$$ y $1, $2, ... $n</i> para poder armar el arbol. 
    </p>

    <h2>Generación de la Tabla de Símbolos y Chequeo de Tipos</h2>
    <p>
      La construcción del <b>AST</b> facilita la creación de la <b>tabla de símbolos</b>, 
      una estructura que permite almacenar información sobre los diferentes identificadores declarados en el programa, 
      como funciones y variables. Gracias a esta tabla es posible realizar distintos tipos de chequeos, 
      entre ellos la verificación de declaraciones de variables, la coherencia de los tipos de retorno, 
      la compatibilidad de tipos en expresiones y operaciones, así como el correcto uso de los identificadores. Es importante destacar que 
      a diferencia de la tabla de simbolos implementada en el pre proyecto, esta puede manejar multiples scopes
    </p>

    <p>
      El proceso se realiza de manera <b>recursiva</b>, recorriendo el árbol desde la raíz y visitando cada nodo. 
      Durante este recorrido se va <b>construyendo la tabla de símbolos</b> e incorporando nuevos identificadores a medida 
      que se detectan declaraciones, al mismo tiempo que se ejecutan los <b>chequeos semánticos</b> necesarios para garantizar 
      la validez del programa.
    </p>

    <p>
      Algunos de los chequeos que se realizan son:
      <ul>
        <li><b>Declaraciones:</b> Verificar que una variable esté declarada antes de ser utilizada.</li>
        <li><b>Duplicación:</b> Evitar que un mismo identificador sea declarado más de una vez en el mismo ámbito.</li>
        <li><b>Tipos de retorno:</b> Confirmar que las funciones devuelvan un valor acorde a su tipo declarado.</li>
        <li><b>Operaciones:</b> Comprobar la compatibilidad de tipos en expresiones aritméticas y lógicas 
            (por ejemplo, impedir la suma entre un <i>booleano</i> y un <i>entero</i>).</li>
        <li><b>Llamadas a funciones:</b> Validar la cantidad y tipo de parámetros pasados en cada llamada.</li>
      </ul>
    </p>

    <h2>Implementación de la Tabla de Símbolos</h2>
    <p>
    La <b>tabla de símbolos</b> se diseñó para manejar múltiples <i>scopes</i> o ámbitos de manera anidada. 
    Cada ámbito corresponde a un bloque del programa (funciones, condicionales, bucles, etc.), y se implementó utilizando 
    una <b>pila de tablas</b>. Esto permite que al entrar en un nuevo bloque se cree un nuevo scope (push), y al salir se elimine (pop), 
    siguiendo un modelo de alcance léxico similar al de lenguajes de programación modernos.
    </p>

    <p>
    Cada scope contiene una <i>lista enlazada de símbolos</i>, donde cada símbolo representa una variable o un método. 
    Un símbolo guarda información como el nombre, tipo de dato, y en caso de métodos también su tipo de retorno y parámetros.
    </p>

    <h3>Estructuras principales</h3>
    <pre>
    /*
    Estructura de los símbolos que se guardan en la tabla
    */
    typedef struct symbol {
        union type *info;   // Información del identificador
    } symbol;

    /*
    Lista enlazada que implementa los ámbitos del programa
    */
    typedef struct symbol_table {
        NodeType nodeType;         // Tipo de nodo (variable, método, etc.)
        symbol s;                  // Información del símbolo
        struct symbol_table *next; // Siguiente símbolo en el mismo scope
    } symbol_table;

    /*
    Nodos del stack de tablas
    */
    typedef struct node_s {
        symbol_table* data; // Tabla de símbolos de un scope
        struct node_s* next;
    } node_s;

    /*
    Stack que implementa la tabla de símbolos
    */
    typedef struct tables_stack {
        node_s* top; // Scope más interno
    } tables_stack;
    </code></pre>

    <p>
    Gracias a esta estructura es posible:
    </p>
    <ul>
      <li>Insertar símbolos en el scope actual verificando duplicados.</li>
      <li>Buscar un símbolo recorriendo la pila desde el ámbito más interno hacia el global.</li>
      <li>Manejar correctamente la vida de las variables en bloques anidados (push y pop).</li>
    </ul>

    <h3>Ejemplo de funcionamiento</h3>
    <p>
    Al analizar un programa que contiene una función con variables locales y un bucle, 
    el stack de tablas de símbolos se comporta de la siguiente manera:
    </p>
    <ol>
      <li>Se crea el scope global (tabla global).</li>
      <li>Al declarar un método, se inserta en la tabla global y se crea un nuevo scope para sus parámetros y variables locales.</li>
      <li>Al entrar en un <code>while</code> o un <code>if</code>, se hace <b>push</b> de un nuevo scope temporal.</li>
      <li>Al salir del bloque, se hace <b>pop</b> y las variables de ese ámbito dejan de estar disponibles.</li>
    </ol>

    <h2>Control de errores semánticos</h2>
    <p>
      Para que el análisis semántico pueda informar errores de manera precisa, como errores de tipos o variables no declaradas, 
      cada token generado por el analizador léxico lleva información de su <b>línea y columna</b>. 
      Esta información se utiliza en la construcción de los nodos del AST para que cada nodo conozca su ubicación exacta en el código fuente.
    </p>

    <p>
      En el lexer (Flex) se mantiene una variable global <b>yylineno</b> que indica la línea actual, y otra variable <b>yycolumn</b> que indica la columna. 
      Cada vez que se reconoce un token, se actualizan estas posiciones según los caracteres que contiene el token, incluyendo los saltos de línea dentro de comentarios o literales.
    </p>

    <pre>
    void update_pos(const char* text, int length) {
        int col = yycolumn; // columna de inicio del token
        for (int i = 0; i &lt; length; i++) {
            if (text[i] == '\n') {
                yylineno++;
                col = 1;  // reinicia la columna
            } else {
                col++;
            }
        }
        yycolumn = col;
    }
    </pre>

    <p>
      Cada token también guarda esta información en la estructura <i>YYLTYPE</i>, permitiendo al parser acceder 
      a <b>@n.first_line</b> y <b>@n.first_column</b> en las acciones semánticas. 
      Esto permite, por ejemplo, que una operación inválida como <code>true && 10</code> genere un error indicando 
      la posición exacta del operador <code>&amp;&amp;</code> en el código fuente.
    </p>

    <p>
      De esta forma, cualquier mensaje de error semántico puede mostrar la línea y columna correctas, incluso si existen comentarios multilínea, espacios o saltos de línea dentro del código.
    </p>


    <h2>Division del Trabajo</h2>
    <p>
      Debido a la complejidad de las tareas, se realizó una división del trabajo entre los dos integrantes del grupo. 
      Uno encargado de la implementación del Árbol de Sintaxis Abstracta (AST), mientras el otro llevó a cabo el desarrollo de 
      la tabla de símbolos. Finalmente, el chequeo de tipos fue abordado de manera conjunta por ambos integrantes.
    </p>

  </main>
  

  <footer>
    <a href="index.html">← Volver al índice</a>
  </footer>
</body>
</html> 