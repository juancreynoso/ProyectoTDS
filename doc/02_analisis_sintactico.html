<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Análisis Sintáctico</title>
  <link rel="stylesheet" href="css/style.css">
</head>
<body>
  <header>
    <h1>Análisis Sintáctico</h1>
    <nav>
      <ul>
        <li><a href="index.html">Inicio</a></li>
        <li><a href="01_analisis_lexico.html">Análisis Léxico</a></li>
        <li><a href="02_analisis_sintactico.html">Análisis Sintáctico</a></li>
        <li><a href="03_analisis_semantico.html">Análisis Semántico</a></li>
        <li><a href="04_codigo_intermedio.html">Generación de Código Intermedio</a></li>
        <li><a href="05_codigo_objeto.html">Generación de Código Objeto</a></li>
        <li><a href="06_optimizacion.html">Optimización</a></li>
      </ul>
    </nav>
  </header>

  <main>
    <h2>Descripción</h2>
    <p>El análisis sintáctico es realizado por el parser que Bison genera a partir de la gramática 
    definida en el archivo <i>sintax.y</i>. El parser recibe los tokens del lexer y verifica que 
    el programa cumpla con la estructura del lenguaje, construyendo simultáneamente la representación 
    interna del programa para las fases posteriores.</p>
    
    <p>Esta fase es fundamental ya que establece la estructura jerárquica del código fuente y 
    detecta errores sintácticos, proporcionando la base para el análisis semántico.</p>

    <h2>Herramientas</h2>
    <ul>
      <li><strong>Bison</strong>: construye el parser LALR(1) automáticamente a partir de la gramática BNF</li>
      <li><strong>Integración con Flex</strong>: recibe tokens mediante la función <code>yylex()</code></li>
      <li><strong>Acciones semánticas</strong>: construcción de estructuras de datos durante el parsing</li>
    </ul>

    <h2>Arquitectura del Parser</h2>
    
    <h3>Tipo de Parser: LALR(1)</h3>
    <ul>
      <li><strong>Look-Ahead LR:</strong> 1 token de anticipación para resolver ambigüedades</li>
      <li><strong>Bottom-up:</strong> construcción del árbol desde las hojas hacia la raíz</li>
      <li><strong>Generación automática:</strong> Bison genera el código C del parser automáticamente</li>
      <li><strong>Eficiente:</strong> adecuado para la mayoría de construcciones de lenguajes de programación</li>
    </ul>

    <h2>Ejemplo de Definición de Reglas</h2>
    <p>Los tokens generados por el analizador léxico son utilizados en esta etapa. Para que Bison 
    pueda reconocerlos, se deben declarar con <strong>%token NOMBRE_TOKEN</strong>.</p>
    
    <h3>Declaración de Tokens</h3>
    <pre>%token PROGRAM EXTERN VOID BOOL INT RETURN CONST
%token IF ELSE THEN WHILE
%token EQUALS ASSIGN PLUS SUB MULT DIV REST
%token LT GT OR AND NOT
%token PAREN_L PAREN_R LLAVE_L LLAVE_R COMA PYC
%token VAL_BOOL NUM ID</pre>

    <h3>Reglas Gramaticales</h3>
    <pre>prog: PROGRAM LLAVE_L declarations LLAVE_R
    ;

declarations:
            | declarations declaration
            ;

declaration: var_decl 
           | meth_decl
           ;

meth_decl: type ID PAREN_L meth_args PAREN_R block
         | type ID PAREN_L meth_args PAREN_R EXTERN PYC
         | VOID ID PAREN_L meth_args PAREN_R block
         | VOID ID PAREN_L meth_args PAREN_R EXTERN PYC
         ;

expr: ID
    | NUM
    | meth_call
    | expr PLUS expr
    | expr SUB expr
    | expr MULT expr
    | expr DIV expr
    | PAREN_L expr PAREN_R
    ;</pre>

    <h2>Manejo de Precedencia y Asociatividad</h2>
    
    <h3>Declaraciones de Precedencia</h3>
    <pre>%left OR AND  
%left EQUALS
%left LT GT
%left PLUS SUB
%left MULT DIV REST
%right NOT</pre>
    
    <h3>Orden de Precedencia (de menor a mayor):</h3>
    <table>
      <tr><th>Nivel</th><th>Operadores</th><th>Asociatividad</th><th>Descripción</th></tr>
      <tr><td>1</td><td>||</td><td>Izquierda</td><td>OR lógico</td></tr>
      <tr><td>2</td><td>&&</td><td>Izquierda</td><td>AND lógico</td></tr>
      <tr><td>3</td><td>==</td><td>Izquierda</td><td>Igualdad</td></tr>
      <tr><td>4</td><td>&lt;, &gt;</td><td>Izquierda</td><td>Relacionales</td></tr>
      <tr><td>5</td><td>+, -</td><td>Izquierda</td><td>Suma, resta</td></tr>
      <tr><td>6</td><td>*, /, %</td><td>Izquierda</td><td>Multiplicación, división, módulo</td></tr>
      <tr><td>7</td><td>!</td><td>Derecha</td><td>NOT lógico (unario)</td></tr>
      <tr><td>8</td><td>( )</td><td>No asociativo</td><td>Paréntesis</td></tr>
    </table>

    <h2>Dificultades Encontradas y Resolución</h2>
    <p>Durante el desarrollo del analizador sintáctico se enfrentaron diversos conflictos en la 
    construcción de la gramática. Particularmente, conflictos reduce/reduce y shift/reduce al 
    modelar la relación entre declaraciones de variables y métodos.</p>
    
    <h3>Primer Intento</h3>
    <pre>prog: PROGRAM LLAVE_L declarations LLAVE_R
    ;

type: | BOOL | INT ;

return_type: | VOID ;

declarations: var_decl
            | method_decl
            ;

var_decl: /* vacío */
        | type ID PYC var_decl
        ;

method_decl: /* vacío */
           | return_type ID PAREN_L PAREN_R LLAVE_L LLAVE_R
           ;</pre>
    
    <p><strong>Problema Identificado:</strong> El uso de producciones vacías en casi todas las reglas 
    generaba ambigüedad: el parser no sabía si reducir hacia <code>var_decl</code> o hacia <code>method_decl</code>, 
    causando <strong>reduce/reduce conflicts</strong>.</p>

    <h3>Segundo Intento</h3>
    <pre>prog: PROGRAM LLAVE_L var_decl_list method_decl_list LLAVE_R
    ;

var_decl_list: | var_decl_list var_decl ;   
method_decl_list: | method_decl_list method_decl ;    

var_decl: /* vacío */
        | type ID PYC var_decl
        ;

method_decl: /* vacío */
           | return_type ID PAREN_L PAREN_R LLAVE_L LLAVE_R
           ;</pre>
    
    <p><strong>Problema Persistente:</strong> Aunque se separaron <code>var_decl_list</code> y <code>method_decl_list</code>, 
    el uso reiterado de producciones vacías seguía generando <strong>shift/reduce conflicts</strong>. 
    El parser quedaba en duda si continuar leyendo declaraciones o reducir inmediatamente una lista vacía.</p>

    <h3>Versión Refinada (Final)</h3>
    <pre>prog: PROGRAM LLAVE_L declarations LLAVE_R
    ;

declarations: | declarations declaration ;

declaration: var_decl | meth_decl ;

var_decl: var_type ID ASSIGN expr PYC ;

meth_decl: var_type ID PAREN_L meth_args PAREN_R block
         | var_type ID PAREN_L meth_args PAREN_R EXTERN PYC
         | VOID ID PAREN_L meth_args PAREN_R block
         | VOID ID PAREN_L meth_args PAREN_R EXTERN PYC
         ;

meth_args: | args_list ;

args_list: var_type ID args_list_tail ;

args_list_tail: | COMA var_type ID args_list_tail ;

block: | var_decl block | statement block ;

statement: ID ;

expr: ID | NUM | expr PLUS expr | expr SUB expr 
    | expr MULT expr | expr DIV expr | expr REST expr
    | PAREN_L expr PAREN_R | VAL_BOOL 
    | NOT expr | expr OR expr | expr AND expr
    ;

var_type: BOOL | INT ;</pre>
    
    <h3>Solución Implementada:</h3>
    <ul>
      <li><strong>Eliminación de producciones vacías innecesarias</strong> que causaban ambigüedad</li>
      <li><strong>Unificación</strong> de <code>var_decl</code> y <code>meth_decl</code> bajo la regla común <code>declaration</code></li>
      <li><strong>Recursión estructurada</strong>: las listas se construyen de forma recursiva por la izquierda, evitando ambigüedades</li>
      <li><strong>Separación clara</strong> entre diferentes tipos de construcciones sintácticas</li>
    </ul>

   <p>
    <b>NOTA:</b> es importante destacar que por la forma que tiene la gramatica, las declaraciones de funciones y variables globales se pueden intercalar.
   </p>

   <h2>Manejo de Errores Sintácticos</h2>

    <p>El parser implementa una estrategia de <strong>detención inmediata</strong> al detectar errores sintácticos. 
    Esto significa que cuando se encuentra el primer error, el análisis se interrumpe y no continúa 
    procesando el resto del código fuente. Como consecuencia, si existen múltiples errores sintácticos 
    en el programa, solo se reportará el primero encontrado, y los errores subsecuentes permanecerán 
    ocultos hasta que el error inicial sea corregido.</p>

    <h3>Implementación del Manejo de Errores</h3>
    <pre><code>int yyerror(const char *s) {
        fprintf(stderr, "Error sintáctico: %s en la línea %d\n", s, yylineno);
        return 0;
    }</code></pre>

    <h4>Características del Sistema de Errores:</h4>
    <ul>
        <li><strong>Detección temprana:</strong> El primer error detiene el proceso de análisis</li>
        <li><strong>Información contextual:</strong> Se reporta una línea aproximada donde ocurre el error</li>
    </ul>

    <h2>Testing y Validación</h2>
    
    <h3>Casos de Prueba</h3>
    <h4>Programas Válidos</h4>
    <ul>
      <li>Declaraciones de variables simples</li>
      <li>Funciones con parámetros</li>
      <li>Expresiones complejas anidadas</li>
      <li>Estructuras de control</li>
    </ul>
    
    <h4>Casos con Errores</h4>
    <ul>
      <li>Paréntesis no balanceados</li>
      <li>Punto y coma faltante</li>
      <li>Declaraciones malformadas</li>
      <li>Expresiones incompletas</li>
    </ul>

    <h3>Resultados Obtenidos</h3>
    <h4>Éxitos</h4>
    <ul>
      <li>Eliminación completa de conflictos shift/reduce</li>
      <li>Parsing correcto de todos los programas válidos</li>
      <li>Recuperación exitosa en la mayoría de errores</li>
    </ul>
    
    <h4>Áreas de Mejora</h4>
    <ul>
      <li>Mensajes de error más específicos</li>
      <li>Captura de múltiples errores en una sola corrida del parser</li>
    </ul>
  </main>

  <footer>
    <a href="index.html">← Volver al índice</a>
  </footer>
</body>
</html> 